constant IC_NOP = h"00"; -- 
constant IC_HLT = h"ff"; -- halted = VCC
constant IC_LDA = h"10"; -- Ar = mem[ir.addr]
constant IC_STA = h"20"; -- mem[ir.addr] = Ar
constant IC_JMP = h"30"; -- ip = ir.addr

subdesign cu_block
(
    clk : input;
    icr[7..0] : input;

    ip_mode : output;
    ip_ena : output;
    ip_abus_ena : output;

    mem_write : output;
    mem_dbus_ena : output;

    ir_ena : output;
    ir_abus_ena : output;
    
    ar_ena : output;
    ar_dbus_ena : output;

    halted, error : output;
)

variable
    fsm : machine
        with states (   
                        start,
                        setting_mem_addr,
                        getting_mem_data,
                        processing,
                        changing_ip,

                        halted,
                        error,

                        lda_setting_mem_addr,
                        lda_getting_mem_data,

                        sta_writing
                    );

begin
    defaults
        ip_mode = GND;
        ip_ena = GND;
        ip_abus_ena = GND;

        mem_write = GND;
        mem_dbus_ena = GND;

        ir_ena = GND;
        ir_abus_ena = GND;

        ar_ena = GND;
        ar_dbus_ena = GND;

        halted = GND;
        error = GND;
    end defaults;

    fsm.(reset, ena, clk) = (GND, VCC, clk);

    case fsm is
        when start =>               fsm = setting_mem_addr;
            ip_abus_ena = VCC;

        when setting_mem_addr =>    fsm = getting_mem_data;

        when getting_mem_data =>    fsm = processing;
            mem_dbus_ena = VCC;
            ir_ena = VCC;

        when changing_ip =>         fsm = setting_mem_addr;
            ip_abus_ena = VCC;

        when halted =>              fsm = halted;
            halted = VCC;

        when error =>               fsm = error;
            error = VCC;

        when processing =>
            case icr[] is
                when IC_NOP =>          fsm = changing_ip;
                    ip_mode = GND; -- increment ip
                    ip_ena = VCC;

                when IC_HLT =>          fsm = halted;

                when IC_LDA =>          fsm = lda_setting_mem_addr;
                    ir_abus_ena = VCC;

                when IC_STA =>          fsm = sta_writing;
                    ar_dbus_ena = VCC;
                    ir_abus_ena = VCC;
                    mem_write = VCC;

                when IC_JMP =>          fsm = changing_ip;
                    ir_abus_ena = VCC;
                    ip_mode = VCC;
                    ip_ena = VCC;

                when others =>          fsm = error;

            end case;


        % L D A %
        when lda_setting_mem_addr => fsm = lda_getting_mem_data;
        when lda_getting_mem_data => fsm = changing_ip;
            mem_dbus_ena = VCC; -- read data
            ar_ena = VCC; -- write it to Ar

            ip_mode = GND; -- increment ip
            ip_ena = VCC;

        % STA %
        when sta_writing =>         fsm = changing_ip;
            ip_mode = GND;
            ip_ena = VCC;

    end case;
end;
